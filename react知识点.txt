1.虚拟dom  抽象js  当数据更新时,react会更新虚拟dom，新旧两个虚拟dom进行比较，（diff算法),
真实dom渲染只需要渲染新旧虚拟dom不同之处
2.创建虚拟dom React.createElement('h1',{id:'ab'},'hello')
3.Router路由器(Browswer需要服务器配置 Hash) 包裹所有的Route Route是单个路由 Switch 只选择一个路由  exact精准匹配
Prop.children包含组件开始标签和结束标签之间的内容	
4.高阶组件 withRouter  export default withRouter(App) 
   将不是路由切换的组件 将react-router的history location match传到props上
    connetct react--redux
   高阶函数  定时器 延时器 、
5.父传子 传属性 字传父 传方法
7.redux  页面或者Action create 派发action action一般有type 和 payload 
   store会调用reducer reducer会返回新的一个state state发生变化后,store可以调用监听函数监听
  到数据的变化 store.subScribe   store..getState()会得到当前的状态
8.因为store仅支持同步数据流 需要用到中间件处理异步请求
   redux-thunk  可以调用store 的 dispatch方法 返回一个函数
   redux-saga 将所有的异步集中在sagas.js处理  saga通过generator创建 页面派发action 传入 sagas
   sagas进行异步处理（ yield Effects ），再派发给reducer，reducer返回state
9.合并reducer  combineReducers
10.react-redux    结合redux  通过connetct(m1apStateToProps,11mapDispatch)(APP)生成容器组件
      react-redux 用provider提供器将容器组件包裹起来 ，将store数组给到容器组件,
     第一个参数 把store里面的数据映射到props里面  
     const mapStateToProps = (state) => {
  return state;
};
    第二个参数  用来派发action   <p>{props.inputValue}</p>
11.hooks 解决functon组件没有自己的生命周期 没有自己的状态等问题
      (1)  useState  返回一个state和更新state的数组 ，参数可写初始值 
             合成时间和声明周期中是异步
             普通事件和定时器延时器是同步
      (2)   useEffect 副作用  主要用来模拟生命周期  
             componentDidMount useEffect(()=>{},[])
             componentDidUnmout useEffect(()=>{return },[])
             componentDidUpdate  useEffect(()=>{},[arr])
      (3)   useMemo 解决不想关状态不再渲染 
              useMemo是dom 更新时执行类似 shoucomponentupdate
              useEffect 是compnentDidUpdate  
     （4）useRef 取到dom结构 
                 const refs = React.createRef()
                 <p ref={refs}></P>  useEffect(()=>{console.log(refs.current.innerText})
       (5) useContext 用于组件状态共享 
             父组件创建上下文   const childContext = createContext() 
             通过这个创建的上下文传递数据 类似react-redux 
              <childContext.Provider value={count}
                    <Child />
      
              </childContext.Provider>
              子组件 用  const count = useContext(childContext)拿到数据
        (6) useReducer 单组件复杂的数据状态管理
             const [count,dispatch] = useReducer((state,action)=>{},10)
            与redux比较像
12. umi  可插拔级的企业级react应用框架
      内置 react、react-router   dva 
       可以用约定式路由或者配置路由
       插件体系
       支持TS
 13  dva  基于redux redux-saga react-router的数据流框架 
namespace 命名空间  在models外面调用action  type需要加上命名空间
        state是状态的初始值  
       reducer 类似redux中的reducer 唯一可以修改state的地方   state action两个参数
        effects:用于处理异步  使用generator  通过call调用数据  通过yield put触发action 然后通过reducer更改state
        subscriptions 订阅数据源 可处理一些逻辑  
         通过connect连接组件 将数据映射到组件中 props
14. purcomponent与component功能基本相同 pur可以通过浅比较实现类似于shouldComponentUpdate的功能
      基本数据类型 根据state的变化决定是否重新渲染  引用类型只有地址变化才会重新渲染
       扩展运算符可以更改引用类型的地址   如果数据经常改变，不适合用Pur,因为浅比较需要时间 ，适合展示组件
15.diff算法
      虚拟dom转成真实dom的最少操作过程，称为调和。diff算法就是调和的具体实现
       diff策略：tree diff 跨层级比较 这个可以忽略不计 可以用css方法显示隐藏
                       component diff 同类组件 层级比较  不同类：会替换所有节点 可以通过shouldComponentDIdupdate进行优化
                       element diff 通过唯一key值区分 有删除 插入 移动
                       移动时  当前的index小于以前的index 才会移动 这个就有了弊端 当最后一个元素 移动第一个时需其他元素全部移动
16.组件懒加载  webpack+import/import 高阶函数/import async 高阶函数/require.ensure 高阶组件
17. 混合开发  webview内嵌页面  或者整个活动页面由web开发 
       webApp  cordova打包到各平台
       原生  react-native  expo.io
18.  声明周期是到特定时间就会执行的钩子函数
        1.初始化 
         2.componentwillmount  render componentdidmout 
         3.(componentwillrecieveprops)  shouldcomponentupdate componentwillupdate render componentDidupdate
         4.componnetwillunmount
           移除 componentwillmount componentwillrecieveprops componentwillupdate
           增加  getDerivedStateFromProps(nextProps,prevtate) 可以控制props更新state  初始化和update阶段触发
            增加  getsnapshotbeforeupdate      didupdate前dom更新后调用    用于读取最新的dom数据
     
 19. super 不写 consturcot 拿不到props  在constuctor之外可以
  20.容器组件作为展示组件或者其他组件提数据和行为
        展示组件 基本不会有自身的状态
  21.     function 与 class的区别 
class有自身的状态 funtion可以用state
class有声明周期 function可以模拟声明周期
function运行效率比class高
无状态组件 没有自己的私有状态和声明周期
有状态组件 有自己的state和声明周期
22.受控组件 每一个更改都需要去执行相关程序
     非受控 在自身内部存储状态  可通过ref去取值
23.为什么react使用className  class是js关键字 而jsx又是js的扩展
24. <React.Fragment> 空标签 
25.检测Props的属性 propTypes         
26.react优点 使用虚拟dom提高性能 jsx代码易于读写 支持客户端和服务端渲染  可以通过多种方式处理性能
27.模块化开发  不同的模块有着不同的功能
   优点:避免变量污染，解决命名冲突
           提高代码复用率
           提高代码维护性

  函数封装  自调用函数  
   common.js  module.exports暴露出去  通过require引入
   AMD  函数库 requireJS  define定义模块  require加载模块
   CMD   sea.js 
    ES6  import 引入 export/export default               
            
28.gulp  基于任务 基于流  太晚gulpfile.js   gulp在进行项目构建时将本地文件读取到gulp内存，操作完成后再输出到本地
  插件  合并文件 编译sass  压缩文件 热更新 打包

29.git remote -v 查看远程关联
       git remote rm origin 解除远程关联
       git remote add origin ''关联远程
       git push -u origin master 第一次推送
       git clone -b '指定分支' ''
       git checkout -b '' 创建并切换分支
       git checkout ''  切换分支
       git branch ''   创建分支
       git merge ''  合并分支
       git statuis 查看工作区作态
       git log 历史版本
       git  reflog  每一次的命令
