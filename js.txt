1.JS包括ES dom bom
2.typeof null   object   typeof  NaN    number    typeof一个函数  'function'
3.函数  由事件驱动或者被调用可重复执行的代码块  增加了复用性 减少代码冗余
4.arguments是保存了所有实参的一个集合 用在函数内部 伪数组
5.作用域 变量或者函数可以被访问到的范围
6.在一个函数内部调用函数自身，那么这个函数称为递归函数
7.构造函数 一个普通函数和new写在一起就称为构造函数 首字母大写
8.访问对象的属性和方法  obj.a  obj.fun()   obj['a']  obj['fun']()   添加 或者修改obj.b=''  删除delete obj.c
9.基本数据类型 number string boolean  symbol ES6新增一个基本类型  {}=>  true
10.数组方法
 push尾部添加元素 pop尾部删除一个元素  unshift头部添加 shift尾部删除
slice 一个或两个参数 原数组不变  splice 1到3个参数 原数组改变 第二个参数表示个数
sort 排序  arr.sort((a,b)=>a-b)
数组翻转 arr.reverse() 
数组拼接join()  
数据合并 arr1.concat(arr2)  
数组遍历 for 
ES5新增  
indexOf  取到某个元素在数组中的索引,没有则返回-1  
forEach 遍历不接受返回值
map 遍历  接受返回值
filter  过滤出所有符合条件的元素  arr.filter(item=>item>3)
some  一个元素满足条件 就为true
every  所有元素均满足条件才为true
reduce  arr.reduce((a,b)=>{})   a为上一次的返回值 b为当前元素

11数组排序方法  冒泡排序 选择排序
12 引用类型 赋值给的是地址     栈区存放 变量名函数名 ，基本类型的值，引用类型的地址 
                                                堆中存放 引用类型的值
13.数组的去重 
   （1）   遍历数组的元素，把数组中的元素作为一个对象的属性名，如果得到的是undefined，就把这个元素
  赋一个不为undefined的值，并添加到一个新的数组中
    （2）  遍历数组中的元素,并且新建一个数组，如果newArr.indef(arr[i])==-1,就添加到新数组
      (3)     因为set的特性 直接将数组放入  var set = new Set(arr)
14.严格模式 规避了代码不严谨不规范的地方 提高了安全性  提高了编译器的执行效率  
15.字符串
charAt  取到索引对应的字符
indexOf 取到字符在字符串中索引 没有返回-1  同数组方法
slice 同数组方法 
substring 与slice基本上一样 不过里面参数会自动交换位置
substr  第二个参数表示个数
split 字符串以指定字符分割成数组
replace(oldstr,newstr) 用新的替换旧的
concat 合并 同数组方法
charCodeAt(index) 取到index位置上字符的ASCII码
fromCharCode(n) 通过字符编码n取到字符  是String自身的方法
ES6 
 str.includes('a') 是否包含某字符
16. m-n 的随机数 
Math.floor(Math.random()*(n-m+1)) + m
17.bom 浏览器对象模型 
   location.href 可以读到完整的路径，也可以赋个地址实现页面的跳转
    scrollTop  可视区域距页面顶部的距离  兼容写法 documentElement.scrollTop||document.body.scrollTop
    clientHeight  可视区域的宽度和高度  width+padding 
    scrollHeight  元素内容真实的高度
    offsetHeight Height+padding+border
     offsetTop  当前元素到定位父节点的top方向的距离  到整个页面的顶部
18.dom 文档对象模型
      创建标签节点  document.createElement
      创建文本节点  document.createTextNode
      添加节点  document.body.appendChild
      查询dom   getElementById   getElementsByTagName  getElementsByClassName
      getElementsByName  querySelectorAll   querySelector
      obj.replaceChild(newNode,oldNode) 替换节点
      odiv.cloneNode(true)  true 连子节点一起克隆
      odiv.removeChild(span) 删除节点
      
      获取所有属性节点  oDiv.attributes 
      获取某个节点属性值  oDiv.getAttribute('id')
      增加及修改  setAttribute
      删除 removeAttribute
        
       父节点 oDiv.parentNode
       所有子节点  oDiv.childNodes
       所有子元素节点  oDiv.children 
       
       oDiv.outerHTML  包括div的HTML结构
       oDiv.innerHTML   div内部的HTML结构
       oDiv.innerText  只有文本

       文档碎片节点 document.createDocumentFragment  
       将创建的li放入文档碎片节点 当全部创建完成后 一起给ul  减少页面重绘次数 提高性能
  19. onload 是等页面所有元素加载完成后执行  jq里面$.ready 是dom加载完毕就执行 不包括图片，资源文件
   20.事件对象是事件触发的时候产生的对象 
       事件对象兼容 var evt = e||event
       事件源兼容  var _target = evt.target||evt.srcElement
       clientX 鼠标在可视区域的X坐标
        screenX 鼠标在屏幕的X坐标 
        offsetX    鼠标相对事件源的X坐标
       pageX 鼠标相对于文档的X坐标
        
        得到按键的按键码  evt.keyCode||evt.which
21. dom事件流 由 捕获，事件源，冒泡三部分组成  先捕获在冒泡  
    普通事件 只支持冒泡 
     阻止冒泡   if(evt.stopPropagation){evt.stopPropagation}else{evt.cancalBubble=true}
22  阻止默认行为  evt.preventDefault()现代  evt.returnValue = false  IE低版本
      return false 兼容性好
23  dom二级事件 可以实现捕获 
      现代浏览器
      obj.addEventListener(event,fn,false)  false冒泡 true捕获
       obj.removeEventListener(event,fn,false)   事件不需要加on
       IE低版本   事件名称需加on
       attachEvent 
        detachEvent
 24 事件委托   利用事件冒泡，把本应该添加到某个dom事件上的对象，委托个它的父亲
       如果该dom对象仍继续增加，仍可获取相同属性

 25. ES6 
     let 存在块级作用域  不存在声明提升  会出现暂时性死区  不允许重复声明  不能当成window的属性
     const 声明常量 不允许被更改
     ...rest 剩余操作符
     ...扩展运算符 可以解构
     for of  for(let i of arr) 遍历数组
     箭头函数
    symbol 新增的基本数据类型  symbol的类型值是唯一的   let a = Symbol()  let b = Symbol()   a!=b
  
26 函数的this指向问题 
普通函数谁调用就指向谁
（1）  在一个函数里面被返回出去不算被调用 指向window（闭包）
 （2） 在setTimout里面 仍然指向window  因为setTimeout是window的方法
箭头函数  指向被定义时的this
  27.立即执行的匿名函数  （function(){console.log('aa')}}()

  
     
  
      