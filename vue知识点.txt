1.vue常见指令
    v-cloak解决标签闪烁  写到标签上 并在css上写 [v-clock]{display:none}
    绑定属性 v-bind: 简写为:
     v-html 可以渲染数据，还可以解析标签，  v-html和{{}}仅能渲染数据
     v-for 便利   v-model  表单 可以监听表单的值  
     v-if  会控制dom节点的存在与否      v-show  通过display进行了元素的渲染
     v-on  简写为@    v-for='count in 10' 迭代数字     

2.动态绑定class 可以写成['red','font']的形式绑定多个class  
   可以写成对象的形式 :class='{'red':flag}'
    使用表达式  :class=" flag?'red ':''"

3.key值的作用 为每个元素作一个独特的标识  这牵扯到diff算法 总之 key值是为了更高效的更新虚拟dom

4.时间修饰符
.stop 阻止冒泡  .prevent阻止事件默认行为  ..capture 事件捕获 从外到内  .self 只有点击自己才会触发,不会阻断事件流
.prevent.once 第一次不会跳转 再点就会

5.map 接受返回值   findIndex 返回符合条件的第一个元素的索引，没有符合的则返回-1

6.过滤器 Vue.filter('dateFormat',function(str,pattern='yyyy-mm-dd')) dateFormat是过滤器名字 str是需要过滤的字符串
在过滤的字符旁边写  | dateFormat  局部的在filters里面写

7.声明周期  bc data与methods均为实例化 c 实例化完成，未绑定到页面上 获取不到dom中绑定的vue数据
 bm 数据扔获取不到  m 挂载完成 可以获取到dom绑定的vue数据  bu 数据未改变 u 数据改变 bd可以
进行逻辑处理 清除事件监听器之类  d

8.vue-resource  用this.$http.get的方法请求接口 同axios   可以用axios作全局响应 拦截 将request给vue的原型
Vue.prototype.$http = request

9.组件化的好处  复用性好 扩展性强 

10.this.$nextTick(()=>{}) 将回调延迟到下次dom更新后执行 将一些动态特效写进去

11.async和await 将代码编程更像同步的异步 ，优雅的解决了回调地狱 ，代码清晰准确

12. vue 组件的定义方式 
 (1) Vue.component('componentName',Vue.extend({template:`<div>第一种</div>`}))
 (2)Vue.component('componentName',{template:`<div>第二种<div>`})
 (3)Vue.component('componentNmae',{template:'#tmpl'}}  <template id="tmpl"> </template>
 注册私有组件  在components:{privateName:{template:`<div></div>`}}
全局组件能被所有Vue实例访问 私有只能被创建它的实例使用

13.子组件的data必须是函数  data是函数相当于给每个组件实例创建了私有的数据空间,各个组件实例维护各自的数据

14.父子传参   父传子  在引入的子组件上写入 :list='list'  然后在子组件用props接收
                      子传父  在引入的子组件上协商  @child=''parent" 子组件用this.$emit("child",{参数})传参
                       父组件用parent(payload){}接收参数

 15.动画   .v-enter,.v-leave-to 开始以及结束的状态
                .v-enter-active,.v-leave-active代表动画的过程
               <transition></transition>把需要运动的标签包裹起来 
                也可以在transition上写上name:'my' 将v换成my

16. uerouter将路由规则对象注册到vue实例上，监听url地址的变化，展示对应的组件

17.路由传参   router-link传参 ?传参用this.$route.query接收  /传参 对应的路由上要写/: 用params接收
                     router跳转传参  this.$router.push({})   query:{} query可以和path,name搭配使用
                      params:{} 只能和name搭配使用   刷新数据会丢失  
                      可以写在路径上动态传参
 
18.computed 计算属性 依赖缓存，对于复杂的逻辑应该使用    watch 监听器  需要某个数据变化时做一些事情或者数据经常变化时，
可以监听路由的变化,做逻辑处理

19.el:'#app' 挂载  也可以new Vue({}).$mount('#app')

20. $router 路由器 vueRouter的实例  可以实现跳转 this.$router.push  this.$router.replace 不会添加历史记录
  this.$router.go(n) 可前进或者后退
      $route 当前跳转的路由对象 可获取path .query等信息

21.路由导航守卫 
    全局前置守卫 
    router.beforeEach((to,from,next)=>{})  to正要进入的路由对象 from正要离开的路由对象 next 可以放行或者跳转页面
    组件内守卫beforeRouteEnter(to,from,next){}
    路由独享守卫 beforeEnter(to,from,next){}

21.getters有state一个参数 mutations 有state,payload 两个参数 actions有context,payload两个
  context.commit('',payload) 提交mutations  命名空间namespaced:true 
   index.js 创建new Vuex.store
   state  $store.state.user.count
   gettets  $store.getters['user/getCount']
   mutations  this.$store.commit('user/add',num)
   actions this.$store.dispatch('user/commitAdd',num)
    
    ...mapGetters({'getCount':'user/getCount'}) 写在computed
      ...mapMutations({'addd':'user/add'}),写在methods
   ...mapActions({'commitAddd':'user/commitAdd'})写在methods